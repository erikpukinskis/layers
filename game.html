<html>

<head>
<title>Learning WebGL &mdash; lesson 4</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script src="http://www.senchalabs.org/philogl/PhiloGL/build/PhiloGL.js"></script>
<script src="underscore.js"></script>
<script src="palette.js"></script>
<script src="box.js"></script>
<script src="glower.js"></script>

<script>

Math.identity = function(val) { return val }
var rand = function(max) {
  return parseInt(Math.random()*max);
}

var World = function() {
    this.objects = [];
}

World.prototype.select = function(object) {
  this.selected = object;
  glower.target(object);
}

World.prototype.at = function(position) {
  return _.find(this.objects, function(object) {
    return object.position.distTo(position) == 0;
  });
}

World.prototype.clearGhost = function() {
  if (!world.ghost) { return }
  var i = world.objects.indexOf(world.ghost)
  world.objects.splice(i, 1);
  world.ghost = null;
}

var world = new World();

var randomBox = function() {
  var box = new Box();
  box.setColorSeed([rand(20),11]);
  box.position.set(rand(6)-3, rand(6)-3, -8);
  return box;
}

var addABox = function() {
  box = randomBox();
//  box.position.y = 0;
  if (!world.at(box.position)) {
    world.objects.push(box);  
  }
  return box;
}

_.times(20, addABox);
/* inline 
world.objects[0].position.x = -2
world.objects[1].position.x = -1
world.objects[2].position.x = 0
world.objects[3].position.x = 1*/

world.selected = world.objects[0];
var glower = new Glower(world.selected);

function webGLStart() {
    PhiloGL('lesson04-canvas', {
      program: {
          from: 'ids',
          vs: 'shader-vs',
          fs: 'shader-fs'
      },
      onError: function () {
          alert("An error ocurred while loading the application");
      },
      onLoad: function (app) {
          var gl = app.gl,
              canvas = app.canvas,
              program = app.program,
              camera = app.camera,
              view = new PhiloGL.Mat4,
              rCube = 0;

          gl.viewport(0, 0, canvas.width, canvas.height);
          gl.clearColor(0, 0, 0, 1);
          gl.clearDepth(1);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);

          camera.view.id();

          function setupElement(elem) {
              //update element matrix
              elem.update();
              //get new view matrix out of element and camera matrices
              view.mulMat42(camera.view, elem.matrix);
              //set buffers with element data
              program.setBuffers({
                  'aVertexPosition': {
                      value: elem.vertices,
                      size: 3
                  },
                  'aVertexColor': {
                      value: elem.colors,
                      size: 4
                  },
              });
              //set uniforms
              program.setUniform('uMVMatrix', view);
              program.setUniform('uPMatrix', camera.projection);

          }

          function tick() {
              drawScene();
              PhiloGL.Fx.requestAnimationFrame(tick);
          }

            function drawScene() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                //Draw Cube
                for(var i=0; i<world.objects.length; i++) {
                    setupElement(world.objects[i]);

                    glower.glow();

                    program.setBuffer('indices', {
                        value: world.objects[i].indices,
                        bufferType: gl.ELEMENT_ARRAY_BUFFER,
                        size: 1
                    });

                    gl.drawElements(gl.TRIANGLES, world.objects[i].indices.length, gl.UNSIGNED_SHORT, 0);
                }
            }

          tick();
      }
    });

}

</script>

<script id="shader-fs" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif

  varying vec4 vColor;

  void main(void) {
    gl_FragColor = vColor;
  }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec4 aVertexColor;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  varying vec4 vColor;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vColor = aVertexColor;
  }

</script>

<link rel="stylesheet" href="style.css" />

</head>

<body onload="webGLStart();" id="body">
  <div id="message"></div>
  <canvas id="lesson04-canvas" style="border: none;" width="500" height="500"></canvas>
</body>

<script>
    var mode = 'select';

    document.onkeydown = function (e) {
        if (e.keyCode == k[modes[mode].key]) {
            mode = modes[mode].next;
            setHelp();
        }

        newMode = _.find(modes, function(attr,name) {
            if(k[attr.key] == e.keyCode) {
                return mode = name;
            }
        })

        if (newMode) { return setHelp() }

        if (f = modes[mode].onkeydown) { 
            f(e, arrowKeyDirection(e));
        }
    }

    k = {
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        space: 32,
        m: 77,
        c: 67,
        s: 83,
        n: 78,
    }

    k.directions = [k.up, k.right, k.down, k.left];

    modes = {
        move: {
            help: 'use arrow keys to move',
            next: 'color',
            key: 'm',
            onkeydown: function(e, direction) {
                world.selected.position.x += direction.x;
                world.selected.position.y += direction.y;
                world.selected.position.z += direction.z;        
            },
        },
        color: {
            help: 'change colors with arrow keys',
            next: 'select',
            key: 'c',
            onkeydown: function(e, direction) {
              world.ghost = null;
              var seed = world.selected.colorSeed;
              world.selected.setColorSeed ([
                bounded(seed[0]+direction.x, 0, width),
                bounded(seed[1]+direction.y, 0, height),
              ]);
              console.log("seed is " + world.selected.colorSeed[0] + ',' + world.selected.colorSeed[1]);
            },
        },
        select: {
            help: 'select',
            next: 'move',
            key: 's',
            onkeydown: function(e, direction) {
              if (!_.contains(k.directions, e.keyCode)) { return }
              var newPosition = world.selected.position.clone();
              newPosition.x += direction.x;
              newPosition.y += direction.y;

              if (newObject = world.at(newPosition)) {
                world.select(newObject);
                world.clearGhost();
              } else if (world.ghost) {
                world.ghost.position = newPosition;
              } else {
                setHelp('Press c to place object');
                newObject = randomBox();
                newObject.position = newPosition;
                newObject.setColorSeed([0,20]);
                world.objects.push(newObject);
                world.ghost = newObject;
                world.select(newObject);

              }
            }
        },
    };

    var modeKeys = _.map(modes, function(mode) { return k[mode.key] });

    function arrowKeyDirection(e) {
        var direction = {x:0, y:0, z:0};
        switch(e.keyCode) {
            case k.up: direction.y = 1; break;
            case k.right: direction.x = 1; break;
            case k.down: direction.y = -1; break;
            case k.left: direction.x = -1; break;
        }
        return direction;        
    }

    function bounded(val,min,max) {
        return Math.max(Math.min(val,max), min);
    }

    var color = [12,10];

    function setHelp(message) {
        document.getElementById('message').innerHTML = message || modes[mode].help;        
    }

    setHelp();

</script>
</html>

