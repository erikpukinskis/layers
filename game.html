<html>

<head>
<title>Learning WebGL &mdash; lesson 4</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script src="http://www.senchalabs.org/philogl/PhiloGL/build/PhiloGL.js"></script>
<script src="underscore.js"></script>
<script src="palette.js"></script>

<script>
  function uni(r,g,b) {
      var side = function(r,g,b,off) {
        if (typeof off == 'undefined') { off = 0 }
        r -= off;
        g -= off;
        b -= off;
        return [r,g,b,1,
                r,g,b,1,
                r,g,b,1,
                r,g,b,1];
      }

    return [].concat(
        side(r,g,b,0.1), //front
        side(r,g,b,0.1), //back
        side(r,g,b,0.05), //top
        side(r,g,b,0.05), //bottom
        side(r,g,b,0.2), //right
        side(r,g,b) //left
    );
  };

  var cube = new PhiloGL.O3D.Model({
    vertices: [0, 0,  1,
                1, 0,  1,
                1,  1,  1,
               0,  1,  1,

               0, 0, 0,
               0,  1, 0,
                1,  1, 0,
                1, 0, 0,

               0,  1, 0,
               0,  1,  1,
                1,  1,  1,
                1,  1, 0,

               0, 0, 0,
                1, 0, 0,
                1, 0,  1,
               0, 0,  1,

                1, 0, 0,
                1,  1, 0,
                1,  1,  1,
                1, 0,  1,

               0, 0, 0,
               0, 0,  1,
               0,  1,  1,
               0,  1, 0],

    colors: uni(1,1,1),

    indices: [0, 1, 2, 0, 2, 3,
              4, 5, 6, 4, 6, 7,
              8, 9, 10, 8, 10, 11,
              12, 13, 14, 12, 14, 15,
              16, 17, 18, 16, 18, 19,
              20, 21, 22, 20, 22, 23]
  });

  cube.position.set(1.5, 0, -8);

  var highlight = 0;
  var highlightIncrement = 0.003;

  function colorCube() {
    if ((highlight > 0.05) || (highlight < -0.05)) {
        highlightIncrement *= -1;
    }
    highlight += highlightIncrement;
    var c = hslToRgb(hsl(color[0],color[1]));
    cube.colors = uni(
        c[0]/255+highlight, 
        c[1]/255+highlight, 
        c[2]/255+highlight
    );
  }

  function webGLStart() {
      PhiloGL('lesson04-canvas', {
          program: {
              from: 'ids',
              vs: 'shader-vs',
              fs: 'shader-fs'
          },
          onError: function () {
              alert("An error ocurred while loading the application");
          },
          onLoad: function (app) {
              var gl = app.gl,
                  canvas = app.canvas,
                  program = app.program,
                  camera = app.camera,
                  view = new PhiloGL.Mat4,
                  rCube = 0;

              gl.viewport(0, 0, canvas.width, canvas.height);
              gl.clearColor(0, 0, 0, 1);
              gl.clearDepth(1);
              gl.enable(gl.DEPTH_TEST);
              gl.depthFunc(gl.LEQUAL);

              camera.view.id();

              function setupElement(elem) {
                  //update element matrix
                  elem.update();
                  //get new view matrix out of element and camera matrices
                  view.mulMat42(camera.view, elem.matrix);
                  //set buffers with element data
                  program.setBuffers({
                      'aVertexPosition': {
                          value: elem.vertices,
                          size: 3
                      },
                      'aVertexColor': {
                          value: elem.colors,
                          size: 4
                      },
                  });
                  //set uniforms
                  program.setUniform('uMVMatrix', view);
                  program.setUniform('uPMatrix', camera.projection);

              }

              function tick() {
                  drawScene();
                  PhiloGL.Fx.requestAnimationFrame(tick);
              }

              function drawScene() {
                  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                  //Draw Cube
                  setupElement(cube);

                  colorCube();

                  program.setBuffer('indices', {
                      value: cube.indices,
                      bufferType: gl.ELEMENT_ARRAY_BUFFER,
                      size: 1
                  });
                  gl.drawElements(gl.TRIANGLES, cube.indices.length, gl.UNSIGNED_SHORT, 0);
              }

              tick();
          }
      });

  }

</script>

<script id="shader-fs" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif

  varying vec4 vColor;

  void main(void) {
    gl_FragColor = vColor;
  }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec4 aVertexColor;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  varying vec4 vColor;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vColor = aVertexColor;
  }

</script>

<link rel="stylesheet" href="style.css" />

</head>

<body onload="webGLStart();" id="body">
  <div id="message"></div>
  <canvas id="lesson04-canvas" style="border: none;" width="500" height="500"></canvas>
</body>

<script>
    var mode = 'select';

    document.onkeydown = function (e) {
        if (e.keyCode == k[modes[mode].key]) {
            mode = modes[mode].next;
            setHelp();
        }

        newMode = _.find(modes, function(attr,name) {
            if(k[attr.key] == e.keyCode) {
                return mode = name;
            }
        })

        if (newMode) { return setHelp() }

        if (f = modes[mode].onkeydown) { f(e) }
    }

    k = {
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        space: 32,
        m: 77,
        c: 67,
        s: 83,
        n: 78,
    }

    modes = {
        move: {
            help: 'move and then hit space',
            next: 'color',
            key: 'm',
        },
        color: {
            help: 'change colors with arrow keys',
            next: 'select',
            key: 'c',
        },
        select: {
            help: 'select',
            next: 'move',
            key: 's',
        },
    };

    var modeKeys = _.map(modes, function(mode) { return k[mode.key] });

    function arrowKeyOffset(e) {
        var offset = {x:0, y:0, z:0};
        switch(e.keyCode) {
            case k.up: offset.y = 1; break;
            case k.right: offset.x = 1; break;
            case k.down: offset.y = -1; break;
            case k.left: offset.x = -1; break;
        }
        return offset;        
    }
    modes.move.onkeydown = function(e) {
        offset = arrowKeyOffset(e);
        cube.position.x += offset.x;
        cube.position.y += offset.y;
        cube.position.z += offset.z;        
    }

    function bounded(val,min,max) {
        return Math.max(Math.min(val,max), min);
    }

    var color = [12,10];
    modes.color.onkeydown = function(e) {
        offset = arrowKeyOffset(e);
        color[0] = bounded(color[0]+offset.x, 0, width);
        color[1] = bounded(color[1]+offset.y, 0, height);
    }

    function setHelp() {
        document.getElementById('message').innerHTML = modes[mode].help;        
    }

    setHelp();

</script>
</html>

